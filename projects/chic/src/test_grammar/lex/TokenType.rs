#[derive(Clone, Eq, PartialEq, Debug)]
#[allow(non_camel_case_types)]
pub enum TokenType {
    // Keywords
    INT,
    FLOAT,
    BOOL,
    PUBLIC,
    PRIVATE,
    PROTECTED,
    FUNCTION,
    LET,
    MUTABLE,
    CHARACTER,
    OVERRIDE,
    TAILREC,
    CLASS,
    OBJECT,

    IMPLEMENTS,
    PACKAGE,
    DEFINE,
    DATA,
    CATCH,
    CONST,
    CONTINUE,
    DEFAULT,
    DO,
    IF,
    ELSE,
    ENUM,
    EXTENDS,
    FINAL,
    FINALLY,
    FOR,
    GOTO,
    IMPORT,
    INSTANCEOF,
    INTERFACE,
    LONG,
    NATIVE,
    NEW,
    RETURN,
    SHORT,
    STATIC,
    STRICTFP,
    SUPER,
    SWITCH,
    SYNCHRONIZED,
    THIS,
    THROW,
    THROWS,
    TRANSIENT,
    TRY,
    VOID,
    VOLATILE,
    WHILE,
    TRAIT,
    WITH,
    USE,
    SEALED,
    SELF,
    MATCH,
    ABSTRACT,
    ASSERT,
    BREAK,
    BYTE,
    CASE,
    VAL,
    VAR,
    TYPE,
    LAZY,
    IMPLICIT,
    YIELD,

    // Separators
    LPAREN,
    RPAREN,
    LBRACE,
    RBRACE,
    LBRACK,
    RBRACK,
    SEMI,
    COMMA,
    DOT,

    // Operators
    ASSIGN,
    GT,
    LT,
    BANG,
    TILDE,
    QUESTION,
    COLON,
    EQUAL,
    LE,
    GE,
    NOTEQUAL,
    AND,
    OR,
    INC,
    DEC,
    ADD,
    SUB,
    MUL,
    DIV,
    BITAND,
    BITOR,
    CARET,
    MOD,
    ARROW,
    COLONCOLON,

    ADD_ASSIGN,
    SUB_ASSIGN,
    MUL_ASSIGN,
    DIV_ASSIGN,
    AND_ASSIGN,
    OR_ASSIGN,
    XOR_ASSIGN,
    MOD_ASSIGN,
    LSHIFT_ASSIGN,
    RSHIFT_ASSIGN,
    URSHIFT_ASSIGN,

    // Boolean Literals
    BooleanLiteral,

    // Integer Literals
    IntegerLiteral,

    // Character Literals
    CharacterLiteral,

    Identifier,

    WS,
    COMMENT,
    LINE_COMMENT,
}

impl Display for TokenType {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let s = match self {
            // Keywords
            INT => "INT",
            FLOAT => "FLOAT",
            BOOL => "BOOL",
            PUBLIC => "PUBLIC",
            PRIVATE => "PRIVATE",
            PROTECTED => "PROTECTED",
            FUNCTION => "FUNCTION",
            LET => "LET",
            MUTABLE => "MUTABLE",
            CHARACTER => "CHARACTER",
            OVERRIDE => "OVERRIDE",
            TAILREC => "TAILREC",
            CLASS => "CLASS",
            OBJECT => "OBJECT",

            IMPLEMENTS => "implements",
            PACKAGE => "package",
            DEFINE => "define",
            DATA => "data",
            CATCH => "catch",
            CONST => "const",
            CONTINUE => "continue",
            DEFAULT => "default",
            DO => "do",
            IF => "if",
            ELSE => "else",
            ENUM => "enum",
            EXTENDS => "extends",
            FINAL => "final",
            FINALLY => "finally",
            FOR => "for",
            GOTO => "goto",
            IMPORT => "import",
            INSTANCEOF => "instanceof",
            INTERFACE => "interface",
            LONG => "long",
            NATIVE => "native",
            NEW => "new",
            RETURN => "return",
            SHORT => "short",
            STATIC => "static",
            STRICTFP => "strictfp",
            SUPER => "super",
            SWITCH => "switch",
            SYNCHRONIZED => "synchronized",
            THIS => "this",
            THROW => "throw",
            THROWS => "throws",
            TRANSIENT => "transient",
            TRY => "try",
            VOID => "void",
            VOLATILE => "volatile",
            WHILE => "while",
            TRAIT => "trait",
            WITH => "with",
            USE => "use",
            SEALED => "sealed",
            SELF => "self",
            MATCH => "match",
            ABSTRACT => "abstract",
            ASSERT => "assert",
            BREAK => "break",
            BYTE => "byte",
            CASE => "case",
            VAL => "val",
            VAR => "var",
            TYPE => "type",
            LAZY => "lazy",
            IMPLICIT => "implicit",
            YIELD => "yield",

            // Separators
            LPAREN => "(",
            RPAREN => ")",
            LBRACE => "{",
            RBRACE => "}",
            LBRACK => "[",
            RBRACK => "]",
            SEMI => ";",
            COMMA => ",",
            DOT => ".",

            // Operators
            ASSIGN => "=",
            GT => ">",
            LT => "<",
            BANG => "!",
            TILDE => "~",
            QUESTION => "?",
            COLON => ":",
            EQUAL => "==",
            LE => "<=",
            GE => ">=",
            NOTEQUAL => "!=",
            AND => "&&",
            OR => "||",
            INC => "++",
            DEC => "--",
            ADD => "+",
            SUB => "-",
            MUL => "*",
            DIV => "/",
            BITAND => "&",
            BITOR => "|",
            CARET => "^",
            MOD => "%",
            ARROW => "->",
            COLONCOLON => "::",

            ADD_ASSIGN => "+=",
            SUB_ASSIGN => "-=",
            MUL_ASSIGN => "*=",
            DIV_ASSIGN => "/=",
            AND_ASSIGN => "&=",
            OR_ASSIGN => "|=",
            XOR_ASSIGN => "^=",
            MOD_ASSIGN => "%=",
            LSHIFT_ASSIGN => "<<=",
            RSHIFT_ASSIGN => ">>=",
            URSHIFT_ASSIGN => ">>>=",

            BooleanLiteral => "BooleanLiteral",

            IntegerLiteral => "IntegerLiteral",

            CharacterLiteral => "CharacterLiteral",

            Identifier => "Identifier",

            WS => "WS",
            COMMENT => "/* */",
            LINE_COMMENT => "//...",
        };
        write!(f, "{}", s)
    }
}