关于new应该放在前面还是后面的问题：

1. new A() -- C++/Java的形式
2. A.new() -- Ruby的形式

我打算实现后者，因为1中的new是一个操作符，而2是一个函数，我希望chi的语法结构越少越好。

另一个问题，是否需要用new：

1. A.new()
2. A()

我打算实现后者——这实际上是C++的形式，而C++中也有new操作符，这是因为C++的内存结构是有“栈内对象（没有new）”和“堆内对象（有new）”的区别的，而chi中我目前的打算是：对象只在堆中分配内存。

---

关于可变不可变的控制问题。对于对象的声明，我打算用这样的形式：

1. let a = A(); -- 不可变
2. let mut a = A(); -- 可变

这里面会有一个可能的误区：mut（mutable的缩写）会很容易被认为是Java中的final的反义词，而实际上我打算实现的是C++中的const的反义词（或者更接近C++中const反义词的含义）。这里面的区别是：

```
// 在java中这样的代码是可行的：
int[] arr = {0, 1, 2};
arr[0] = 1;
```

```
// 在C++中这样的代码是会编译报错的：
int const arr[3] = { 0, 1, 2 };
arr[0] = 1; // arr不允许修改
```

array是大多数命令式语言（我还不知道有哪个命令式语言的没有数组的）都自带的内置数据结构，但用户自定义对象要实现“可变/不可变”的语义就需要一个语法来支持，目前的计划是这样：

```
pub class A {
    pvt int x = 0;
    pub fn cannotModifyX() {
        // 默认不能修改x，如果这个函数中有下面这行，就会编译报错
        // this.x = 1;
    }
    pub fn mut canModifyX() {
        // 函数声明中用fn mut，这样就可以编译通过
        this.x = 1;
    }
}

void main(args:str[]) {
    let a = A();
    let mut ma = A();

    a.cannotModifyX(); // 编译成功
    ma.cannotModifyX(); // 编译成功

    a.canModifyX(); // 编译【失败】
    ma.canModifyX(); // 编译成功
}
```

---

关于一些关键字是用全称还是缩写的问题，刚才在写上面的例子的时候就在想，是写```public function ff()```呢？还是写```pub fn ff()```呢？

如果是前者，那么再加上```mut```的时候就不好只写```mut```了，可能要写```mutable```。那么```let mutable```就又显得太难看了。

想来想去还是用了缩写。在可读性上，可能用完整拼写会更好一点，但写起来就麻烦一点。

以后关于关键字制定的原则是：如果预计不会影响可读性，那么就用缩写——现在先这么定，过几天我的想法可能就变了，到时候再改也好改，只是词法的变化而已。

---

刚写到编写的便利性与可读性的平衡，我又想到if后面要不要有括号的问题。我们知道有的语言是必须有括号的（比如C/C++/Java），有的却可以没有（比如go/rust），还有一些语言的结构与括号没有关系的，不存在这个问题，这个就不讨论了，因为chi的语法是类C的样子。

后面的明天再写吧，今天写到这里。