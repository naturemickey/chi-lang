说到泛型第一个需要讲的问题是：```C<A>```与````C<B>````是否是同一个类型？

1. 在Java中，这是同一个类型的（调用getClass方法会获得同一个类名，甚至在大部分情况下内存地址都是同一个——除非用不同的类加载器）；
2. 而在C++中，这会是不同的类型（在C++中，甚至当没有实例化类型参数的时候，连泛型类本身的编译过程都没有做完）。

下面这段C++代码竟然是可以通过编译的。这里奇怪的地方是：在class C的类型参数T实例化为F时，void g()函数是语义错误的（因为F中没有名字为g的函数），但编译器似乎“视而不见”。这是因在整个代码中并没有使用到C类的void g()函数，所以并没有对void g()进行完整的编译——我现在写这段的时候，使用的是g++（Apple clang version 12.0.0 (clang-1200.0.32.2)），不过按经验vs里面也是一模一样的效果（一会儿我再去windows里面试一下）。

```C++
template<typename T> class C {
    T t;
public:
    void f() { t.f(); }
    void g() { t.g(); }
};

class F {
public:
    void f() {}
};

int main() {
    C<F> cf;

    cf.f();
}
```

这是因为在C++编译器中，对于泛型类的未实例化之前，只做了语法检查，而没有做语义的检查。在对泛型参数做实例化之后，就可以做语义检查了，不过也是用到哪个部分检查哪个部分——在这段代码里，```t.g();```这句是语义错误的，因为T被实例化为F类型，但F类型里面没有g，不过这句代码本身的语法结构却是对的。

Java和C++的方式似乎都不是我想要的：

1. 我认为```C<A>```与````C<B>````绝对是两个不同的类型——不再是类型C，而是```类C<A>```和```类C<B>```。
2. C++那种有选择的编译似乎也并不是一个好的机制，这并不是一般的认知中的理解，而是另外一种奇葩的理解。

所以我可能会在字面上选择和Java类似的语法，但在类型的语义上做严格的区隔。

第二个需要想一下的问题是：泛型究竟应该是一个“编译机制”还是一个“预编译机制”？这里的区别就在下面这两段代码的编译结果的不同：

以下C++代码可以通过编译：
```C++
template<typename T> class A : public T {};
```

以下Java代码不能通过编译：
```Java
class A<T> extends T {}
```

单从这里看，C++的选择是一个更优的选择。因为它给语言一个更多的可能性。记得十几年前看《C++设计新思维》里面讲的基于policy的程序设计就是使用了这种机制，换一种语言就没法用这种思维写代码了——对于policy这个词是个什么意思？好像书中也没有翻译，而我的英语也就那样，所以我也就不知道怎么翻译了。

说到翻译，回想在2016年从我们当时的CIO口中听到一个词“invariant”，他是拥有英国永久居留权的人，是讲英语比当时我们的老外顾问讲得还流畅的人，竟然说他也不知道用什么中文来翻译这个词(当时的语境是在讨论一种程序设计的理念)。昨晚在看一本书《数学与泛型编程》时又看到了这个单词，在这本书中invariant的翻译是“不变式”，不过这和我们当时谈的概念却有很大的差异。而invariant究竟是什么涵义呢？既然无法就一个词来翻译，那就要写一篇文章来阐述了。今天就不扯那么远了，以后再想起这个话题再讲吧。

话说回来，对于泛型的编译机制是否是“预编译”这个问题，如果没有其它的替代品，那么我可能会参照C++的机制来做。不过我想Scala的with trait与kotlin中的by似乎都有一定程度的替代能力，只是稍微麻烦了一点，达不到Loki库那样简洁。有了Scala与Kotlin的启发，我可能要想想chi中要用什么样的机制来做这样的事情（当然，也可以放弃这一机制）。现在还没想清楚，以后再写吧。

第三个是泛型本身的语法，其实也没想清楚的。比如：最初接触这一概念是C++然后是Java，所以对于“<>”做为类型参数的字面范围的表示是认为理所当然的，但学习Scala的时候发现竟然是用“[]”的这么“奇葩”，再后来持续两个月使用Scala之后，竟然也“习惯”了。

今天先想到这里吧，每天都是只有晚上有点时间做一些思考笔记，白天只有一些零碎的时间，偶尔能穿插一些短代码的实现——chi的实现进度注定是缓慢的……
