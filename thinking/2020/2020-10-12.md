关于操作符重载，是一个挺有意思的东西，在某些情况下可以大大提高语言的表现力，而在另外一些情况下也会被滥用。

在某些语言中，运算符与函数是一致的语义，在这类语言中并没有运算符重载这个说法，但却可以做到运算符重载的事情。比如下面这行scheme代码：
```scheme
> (define (+ a b) (- a b))
> (+ 1 2)
-1
```
这一行代码蛮有意思的，虽然明显是“滥用”，但在语法上的确“非常简洁”。希望没有程序员这样乱用吧！

如何避免语言机制的滥用是一个比较麻烦的话题，有些语言机制看起来还是蛮酷的，不过一但被滥用造成的麻烦可不小。比如上面这个把加法重定义成减法的。

再比如在Scala中有一个implicit机制，可以让scala代码写出```2 days ago```这样的代码。 第一次看到这样的代码时，我惊呆了，简直是太cool了。程序设计语言竟然可以写出和自然语言一样的语法！不过仔细一想却不是那么回事——如果通篇都是英语的语法，真的会是一个更好的程序么？

不会的。自然语言的容错性是很高的，而程序设计语言的容错性几乎为零；自然语言的结构化是比较差的，用这种语法可能程序员写出语法错误都不好检查（至少不是一眼能看清楚的）。

——另：ruby也能写出```2.days.ago```这样的语言结构。Scala只是可以省略点。

---

说回chi语言，我会怎么来对待操作符重载这种语言机制呢？可能：
- 不支持操作符重载——可能有的时候语言的表达能力会差一些，不过除了会遭到一些用户的吐槽之个，也不会有什么大的问题。
- 如果要支持这一机制，那么：

1. 重载会通过trait的形式来做——实现特定的trait即支持特定的操作符。
2. 内置的类型所支持的操作符也是通过trait实现——保证语言机制单一。
3. 对于类实现trait会是类似于Scala的形式，而不是rust的形式，这是为了保证trait的实现与类的其它实现都由类的设计者来搞定，而不是在类外——C++的operator的非类成员函数的形式是类似的——否则会导致可能出现类的设计者自己意料不一的玩法出来（我希望可以保证一个类的用户对于一个类形的使用不能超出类设计者的想象）。
4. 我可能还会对这些特定的trait有所要求：操作的对象是同质的（属于同一类型的，或者同一类型派生的）。

---

总体上，在设计chi语言的过程中，我会尽量避免【隐式】的转换，以免代码的读者的阅读难度太高。

---

昨天在一个QQ群里谈到语言有优缺点时我说：我觉得Java不错，没有明显的缺点，也没有明显的优点。

立刻有人回复说：没有运算符重载。

所以今天特意写了一下关于运算符重载的想法。其实在我的眼里“没有明显的缺点”的语言就是非常好的语言了。我见过的语言也不算少，发现一个规律：有明显优点的语言，一定有明显的缺点——而且就像《道德经》说的一样“祸兮福所倚，福兮祸所伏”：缺点总是在优点背后藏着。例如：

1. 操作符重载的滥用：操作符重载可以使表达能力提升，也可以使表达能力降低（就比如上面把+变-的操作会使后面的程序员一脸蒙逼）。
2. rust的内存回收：优点是没有GC，性能更好；缺点是非常高的学习门槛。
3. 标榜自己是“纯”函数式语言的语言（Haskell）：无锁，并发性好；缺点是对状态的维护会变得更麻烦。
4. 强大的“宏”机制可以达到元编程的效果：优点是语言机制异常强大，可以在一个语言里面比较容易的创造出一个新的语言；缺点也非常明显，每个程序员都在使用元编程来创造新的语法的话，那可读性就会差到飞起了。

所以，我认为一个没有明显缺点的语言还是挺难得的，虽然Java用起来也并不是特别爽。

---

明天写写泛型吧，上面几行刚刚吐槽了宏机制，而在某些语言中**泛型**就是一个典型的宏机制（如C++）。
