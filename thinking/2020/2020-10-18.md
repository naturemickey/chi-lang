最近思考了一下类似类型定义这样的语言机制，类似于C++中typedef这样的：

```C
typedef int Integer;
```

这种机制明显是一个预编译的机制，换句话说就类似于```#define Integer int```这句差不多，只是在预编译的时候进行一个字面的替换。那么这种机制究竟有多大的必要性呢？

从我的个人习惯来说，可能用处并不大。要说有用的话，可能有两种用处：

一、对于类型很长的时候，可用这种方式来简化书写，比如：
```C++
typedef std::vector<std::vector<int>> VVi;
typedef std::vector<std::vector<int>>::iterator VVii;
```

这样后面的代码中就可以用VVi和VVii这两个短文字来替代```std::vector<std::vector<int>>```和```std::vector<std::vector<int>>::iterator```这两个这么长的类型声名了。在写代码的角度来看确实短了很多，“有可能”会写起来更流畅了。不过可读性就未必了——要想保持良好的可读性就需要谨慎的的选择类型的别名（可能```Vec_Vec_int```还是比```VVi```要更容易理解一点。话说回来，C++11之后修改了auto关键字的含义之后，也在某种情况下缓解了这种长类型名的问题（在C++11之前我竟然不知道有auto这个关键字，可能这就是C++11废弃它的老含义的原因）。

这种好处对于我的习惯来说并不明显，因为我是比较习惯于写完整名的，可能主要的原因还是认为全称的可读性会更好吧。

二、有可能真的需要对一个类型赋予一种新的含义，比如：

```C++
class FA
{
    typedef int State;

    State start, finish;
    State current;
};
```

在这种情况下，可能typedef还算是发挥了一定的作用。不过，按我的习惯，我会这样来实现：

```C++
class State {
    int state;
};

class FA {
    State start, finish;
    State current;
};
```

这样把State真实的定义成一个```class```，这样在性能上其实完全没有额外的开销，因为C++在这种情况下对于State的内存排布就是一个int的大小，是一个无损抽象（rust语言宣称自己是“无损抽象”的，C++并没有宣称自己做到了“无损”，不过大部分情况下也还是无损的），而且这种写法也给未来的扩展带来了更多的可能。

Scala中的type关键字和C++的typedef的功能类似，不过多了一个类型抽象的能力，即：不同的子类可以对同一个抽象化类型实例化为不同的具体类型。
这和泛型实际上是同样的东西，所以就不放在类型定义这个范围来一起看了。

所以，从目前来看，类型定义似乎必要性不足，有可能chi中我不会实现这一语言特性。

---

说回来，对一个类型的“别名”，我们用类继承也是一样可以达到效果的，比如：

以下代码：
```C++
typedef std::vector<std::vector<int>>           VVi ;
typedef std::vector<std::vector<int>>::iterator VVii;
```
用以下代码来替换
```C++
class VVi  : public std::vector<std::vector<int>> {};
class VVii : public std::vector<std::vector<int>>::iterator VVii {};
```
是完全没有任何问题的，所有的其它代码都不用修改直接就可以适用，再加上C++的对象模型对于对象内存的排布在这里又可以保证无损的抽象，更有利的就是我们还可以为新的类型添加新的能力（成员函数等）。所以，当真的有需要的时候，为什么不再定义一个新的类型（而是用别名）呢？

---

在kotlin中的代理（或者有的叫“委托”），也有异曲同工之妙。如：

```kotlin
class Derived(b: Base) : Base by b;
```
这样Derived类型就自动实现了Base的所有方法，并且Derived在调用所有方法时都会代理给b对象——当然，如果有需要Derived类型也是可以添加自己的方法的——这是语言自带的一个设计模式。蛮好，我第一次看kotlin的文档学习到这个部分的时候也是拍案叫绝的——用语法直接实现设计模式还是首次见到（当然，这里是“我”的首次，也有可能我是孤陋寡闻的）。

kotlin这种方式与前面讲的继承的方式在语义上并不等价，只是也有相似的地方，并且在某种程度上，也能实现同样的效果。

---

在rust中，可以用一个无组来定义一个结构体，如：

```rust
struct Integer(f64);
struct Point2D(f64, f64);
```
使用起来也像一个元组一样，这也可以说是为一个元组定义了一个新的名字，用类似Scala的语法可能是这样表示的：```type Point2D = (f64, f64) ```

不过在我看来，这样还不如就用常规的语法定义一个常规的结构体了，因为常规的办法还可以为属性命名，增强可读性。

我倒是希望rust这样的语法可以实现kotlin的代理语义，这样感觉会更漂亮一点。