今天白天忙了一些其它事情，到了晚上才有时间思考chi的事儿。

lambda与函数在“本质”上应该是一样的东西。

在谈到“本质”这个词的时候，通常可能会被理解成两个含义：
1. 在语义上的含义
2. 在具体实现上的含义

比如：在Java中，Integer类型无论在实现上是分配的栈上还是堆上，在语义上都是表示一个整数——虽然现在的jvm的实现中，Integer是在堆上的，但我们是能够做到把这个对象分配到栈上，而且能够保证Java语言的的运行结果与原虚拟机完全一致。虽然这种实现会相对麻烦一些。

lambda与函数在语义上是一样的，只是我们可能通常把函数做为一个固定的逻辑被调用，而lambda被当做“看起来”是运行时创建的“值”（只是这个值里面有逻辑）来使用。不过交换场景来使用也未常不可。

比如(以下代码是伪代码，那个lambda的形式更接近于groovy，而不是rust)：

以下两个代码是等价的（把lambda当做普通函数来使用完全没有问题）
```rust
let fun = {a, b -> a + b};
```
```rust
fn fun(a:i32, b:i32) -> i32 {
    a + b
}
```

以下两个代码也是等价的，不过lambda的形式明显更简洁。
```rust
// 这里的返回值用的是rust的lambda的声明形式
fn add(a:i32) -> Fn(b:i32)->i32 {
    b -> a + b
}
```
```rust
// 这里的返回值用了类似C语言的函数指针的形式，看起来是非常难看的——这里只是为了表示一下含义。
fn add(a:i32) -> int(*)(i32) {
    fn add_inner(b:i32) -> i32 {
        a + b
    }
    return add_inner;
}
```

因为在语义上完全等价，但在使用上不同场景各有便利性，所以我大概会这样来实现：
1. 存在独立函数，但不存在独立的lambda。
2. 如果要实现closure，那么就用lambda，所以chi可能会不允许在函数内部定义函数，但是可以定义函数内部的lambda。
3. 类内部可以有成员函数，也可以有field是lambda类型的。
4. lambda的声明可以指向函数名，例如：
```rust
fn add(a:int, b:int) -> int {
    a + b
}
let lambda:Fn(a:int, b:int)->int = add
```

---

写了这几行“伪”代码，想到一个问题：

1. 函数的return是否可以省略？我还没有下决定：如果不省略，那么lambda就会变得很丑，反之函数的可读性会受到一点影响——可能最终我还是会交给程序员自己来选择吧……