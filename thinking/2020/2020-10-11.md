今天白天忙了一些其它事情，到了晚上才有时间思考chi的事儿。

lambda与函数在“本质”上应该是一样的东西。

在谈到“本质”这个词的时候，通常可能会被理解成两个含义：
1. 在语义上的含义
2. 在具体实现上的含义

比如：在Java中，Integer类型无论在实现上是分配的栈上还是堆上，在语义上都是表示一个整数——虽然现在的jvm的实现中，Integer是在堆上的，但我们是能够做到把这个对象分配到栈上，而且能够保证Java语言的的运行结果与原虚拟机完全一致。虽然这种实现会相对麻烦一些。

lambda与函数在语义上是一样的，只是我们可能通常把函数做为一个固定的逻辑被调用，而lambda被当做“看起来”是运行时创建的“值”（只是这个值里面有逻辑）来使用。不过交换场景来使用也未常不可。

比如(以下代码是伪代码，那个lambda的形式更接近于groovy，而不是rust)：

以下两个代码是等价的（把lambda当做普通函数来使用完全没有问题）
```rust
let fun = {a, b -> a + b};
```
```rust
fn fun(a:i32, b:i32) -> i32 {
    a + b
}
```

以下两个代码也是等价的，不过lambda的形式明显更简洁。
```rust
// 这里的返回值用的是rust的lambda的声明形式
fn add(a:i32) -> Fn(b:i32)->i32 {
    b -> a + b
}
```
```rust
// 这里的返回值用了类似C语言的函数指针的形式，看起来是非常难看的——这里只是为了表示一下含义。
fn add(a:i32) -> int(*)(i32) {
    fn add_inner(b:i32) -> i32 {
        a + b
    }
    return add_inner;
}
```

因为在语义上完全等价，但在使用上不同场景各有便利性，所以我大概会这样来实现：
1. 存在独立函数，但不存在独立的lambda。
2. 如果要实现closure，那么就用lambda，所以chi可能会不允许在函数内部定义函数，但是可以定义函数内部的lambda。
3. 类内部可以有成员函数，也可以有field是lambda类型的。
4. lambda的声明可以指向函数名，例如：
```rust
fn add(a:int, b:int) -> int {
    a + b
}
let lambda:Fn(a:int, b:int)->int = add
```

---

写了这几行“伪”代码，想到一个问题：

1. 函数的return是否可以省略？我还没有下决定：如果不省略，那么lambda就会变得很丑，反之函数的可读性会受到一点影响——可能最终我还是会交给程序员自己来选择吧……

---

说回lambda，对于动态类型语言来说，lambda通常是非常简洁的，而静态类型语言却有点麻烦。比如对于java来说，它的lambda是相当的丑陋，其丑陋主要表现在两个地方：
1. lambda对象的类型声明（长得不得了）
2. lambda对象的调用（java尝试在语言中加入了函数式的东西，但在lambda的调用上还是老样子）

对于熟悉函数式语言的同学，如果尝试用java的lambda实现一下函数式中常见的一些结构就会发现超级不好用（比如：尝试一下实现cons/car/cdr）。

一些静态类型语言通过类型推倒(type infer)来试图解决这个问题，比如在scala或rust中有类似这样的写法（仍然是伪代码）：
```rust
let fun = (a, b) -> a + b; // 这里不知道a,b的类型
let x = 1;
let y = 2;
let c = fun(x, y); // 通过这里反推
```
这种方式可以在大部分的时候，这种类型推倒是OK的，而且也同样使代码与动态语言一样简洁。但是，如果下面再加一段，要如何决策呢：
```rust
let fun = (a, b) -> a + b; // 这里不知道a,b的类型
let x = 1;
let y = 2;
let c = fun(x, y); // 通过这里反推
// 下面三行新增
let m = "m";
let n = "n";
let l = fun(m, n); // 此处第二次反推类型会与第一次冲突：前面是int，这里是string
```
此时，当类型不一样的时候，我们要怎么选择呢？两个可能的方向：
1. 当两次不一致的时候，报编译错误
2. 当两次不一样的时候，内部做两个函数的实例（类似于C++的template）。

目前我的想法是：
1. 对于lambda，倾向于选择前者
2. 对于泛型类和泛型函数，倾向于选择后者

不过这个想法是有矛盾的，因这样的实现就表示lambda与函数之间出现了一个比较大的差异。后面在细想一想，似乎两者不一定必然是对立的，如果可以很好的统一起来就完美了。
