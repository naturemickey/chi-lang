如何比较两个函数是否相等呢？

首先，为什么要比较函数是否相等呢？这是什么场景呢？

我最近就碰到了这样的场景：测试。

在函数式开发中，函数（或者lambda）经常被当做一个“值”作为：参数、返回值、结构的属性，集合中的元素……，总之函数几乎可以在任何基础类型（如：int、float、char等）出现的地方（除非语言本身有所限制）。而学习过lambda演算的同学更加可以理解：一个仅有lambda的虚拟世界中，我们可以用lambda构造出所有现在图灵机能构造出来的结构（数字、布尔值、IF/WHILE等逻辑、元组/链表等数据结构……）。

在测试的时候，我们经常会assert一个结果是否是我们预想的。而这个结果如果本身是一个“函数”或者一个包含函数的结构，那就用到了数据的“相等”比较了。

糟糕的是，当我意识到这是一个问题的时候，竟然不知道哪个语言对这一问题给出了令人满意的答案。

如果语言本身并不支持这个判断，那么最简单的可行办法就是：对这个函数进行黑盒测试，如果满足所有的测试用例，那么我们就认为这个函数是我们预想中的函数——或许可以满足大部分的场景，不过“冒泡排序”与“插入排序”如果实现得当都可以通过同一组测试用例，这样对于内部实现的细节部分就得不到一个准确的判断的。

最近用rust，这个鬼语言就不支持这个，导致我想做状态转换函数的单元测试时遭遇了麻烦。

话说回来，如果是对一个函数的测试，那么难到不是测试逻辑是否正确么？什么情况有必要对比函数的整个实现呢？

举一个小例子：

```js
function add_fun(a) {
    return function(b) {
        return a + b;
    }
}
```

如果要测试```add_fun```这个函数，那么我的测试用例可能有```add_fun(1)```、```add_fun(2)```、```add_fun(3)```，那么如果我可以比较返回值是```function(x) { return 1 + x; }```、```function(x) { return 2 + x; }```、```function(x) { return 3 + x; }```就可以了。但是如果我还需要测试这三个函数那就又变成更多的测试用例了。这还是一个足够简单的测试场景，如果我们的场景更加复杂，指数级的增加测试用例想起来也挺可怕的——难怪单元测试很难推广。

从这个简单的场景里我们可以注意到，实际上我们要测试的，其实并不是这个返回的函数逻辑，而是“闭包”在这个函数里的一个动态的值。

那么，究竟要如何比较两个函数呢？比较容易想到的一个方法是比较两个函数的AST结构。就在上个月我还写了一个比较SQL是否相等的程序（当时是为了做一个SQL语法检查的白名单），也是比较两个SQL的AST。

不过细想起来，比较AST真的能成么？和做SQL白名单相比，至少难度更大，因为：做SQL白名单是纯静态语法分析，而做测试过程中的比较是执行过程中动态的过程，“闭包”本身的值一定不在提前编译的代码里，而在运行时的数据结构里（比如：堆栈），而连引用本身可能都是间接的（类似于汇编中的间接寻址）。

再细想一下，如果我们要测试的是这样一个函数，又如何：

```js
function add_fun(f) {
    return function(x) {
        return f(x);
    }
}
```

闭包的实现本身就有一定的难度，再加上测试时的对照函数并不是闭包的，如何与一个闭包的函数对比呢？

一个简单的办法是：把这个闭包函数实现为一个动态生成的字节码（也就是不做为闭包来实现），不过我不想这么做。

今天就想到这里，没有得到答案。
