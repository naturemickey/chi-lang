所有对象是否应该默认支持```==```操作呢？```==```操作的默认行为应该是什么呢？

有的语言是默认所有对象都可以==的，比如Java。

在Java中```==```的默认行为是比较两个引用所指向的内存地址——不过这种默认行为基本上会被认为是一个反模式（大部分情况下不建议使用，很容易出问题）。这是一个很尴尬的局面，因为Java自己号称是从C++演化过来的语言，但在C/C++中比较常用的操作符，在Java中却很容易被用出问题。

在C++中自定义类型是没有默认的```==```行为的（必须自己写一个```operator==```函数）。其实也没有什么大问题，就是麻烦一点，因为可能90%以上的情况下，这个函数的行为也就是大家常用的那几种逻辑。

最近用rust比较多。在rust中也是没有默认的```==```行为的，有的时候还是挺麻烦的。就连```enum```类型都不能够用```==```来比较——不过这也可能和```enum```在rust中的含义有很大关系：在C++/Java中，enum是不能在使用中修改的，而rust中的```enum```的每一项是动态的数据类型（而不是值）——虽然我理解这种语法的选择，但也确实是没那么好用。举个例子：逻辑是当一个枚举对象是某个值的时候do something，其它时候不做什么，这样我就不能这样写：
```rust
// 注意这是错误写法：
if e == TestEnum::Item {
    // do something
}
```
而要这样写：
```rust
match e {
    TestEnum::Item => {
        // do something
    },
    _ => {},
}
```
感觉挺丑的写法，可读性肯定是不如if好的——虽然模式匹配是比if更强大的语言机制，不过杀鸡焉用机关枪？！

所以，我认为```==```操作如果是一个语言的默认行为的话，那么在程序的表达上也更简单。不过这种默认行为不应该是像Java的那样有点鸡肋的“默认”，而是一个对内容的对比。

内容对比是否是一个很复杂的东西呢？感觉唯一的复杂点就在于对象的循环引用，其它的倒是还好——其实这个所谓的复杂点又能有多复杂呢？

---

拷贝行为或许可以做类似的决策。通常是要“深拷贝”不要“浅拷贝”的，所以或许可以实现默认的“深拷贝”功能，不过我倒是想实现默认的“浅拷贝”，因为chi是以“不变状态”为主的语言，而且也有GC。

在C++中，基本上认为“浅拷贝”是不可取的行为，因为那样将非常难以管理copy过去的指针所指向的地址的释放问题。不过在Java中，我倒是有那么一次感觉“浅拷贝”也是挺好用的，不过这是另一个话题了。

---

话说回来，如果默认提供了```==```与```clone```那么碰到不希望有这两种行为的时候要怎么办呢？比如：要实现单例模式的时候，我们就需要屏蔽clone的行为了。

在C++中是有默认的拷贝构造函数的，当用户需要屏蔽的时候，就自己实现一个放到```private```部分去，这种方法是可行的。即：默认提供，但给机会屏蔽。也有另外一种做法：默认不提供，但可以简单的加上去一个编译器的默认实现。

我可能更倾向于后者。