说说几个关键字。

# ```override```
```override```一般用在子类（或者有的语言叫派生类）中，用于表示当前所修饰的方法（或函数）会重写父类（或者叫超类、基类）中相同签名的方法。比如AS3（ActionScript 3.0）

有的时候```override```不是一个关键字，而是一个注解（```@Override```），比如java，不过含义一样。

有的时候```override```不是在子类中，而是在父类中，比如C++，用来表示“子类必须```override```这个成员函数，否则编译报错”，目的还是一样的。

简单说就是：写了```override```的函数会被校验（子类与父类的声明一致性）。

不过反过来（没有写override的情况下）就没有校验了。感觉可能还是要有校验比较好。逻辑也反过来：没有override则不应该有与当前函数相同的声明——以免不小心重写了本没打算重写的函数。

# ```tailrec```
这是kotlin的一个关键字，代表当前函数需要编译器执行尾递归优化。

我一开始看到这个关键字是有一点奇怪的，因为我认为在函数式语言中，“尾递归优化”应该是一个默认行为，而在kotlin中需要程序员指定是有点奇怪的——更何况很多程序员都并不知道有尾递归优化这回事！

没想到什么正面的合理的理由能解释这个。想来可能是编译器的开发者的某种权衡？猜测可能如果每个函数都做这个判断会导致整个编译时长拉长？——纯猜测。

反过来看，如果一个函数可以做尾递归优化，但是不做的话，有没有额外的好处呢？其实也是有的，就是可以“堆栈溢出”——“堆栈溢出”可以称之为好处么？大部分是坏的，个别情况下是好的：
- 当算法实现的正确性与性能等没有问题的时候，那么自然是要执行完成它，产生它应有的价值，在这种情况下我们使用尾递归优化可以使性能更好，同时也避免了可能的堆栈溢出——不过编译器基本上也不能判断算法实现是否正常的。
- 当算法实现有点垃圾的时候就不好说会怎么样了，所以在这个时候，少量的递归可以执行，大量的递归就堆栈溢出，这样也可以保护我们的系统整体不会被烂代码拖垮。在这种情况下如果有做了尾递归优化，那可能产生的灾难就不好说了（可能内存溢出，或者可能死循环……）——不过最大的灾难也就是软件崩溃而已，怎么也不至于让我的机器爆炸，所以可能也还是可控的——同样的，编译器也不知道算法实现怎么样的。

上面说到编译器不知道算法实现是否适合做尾递归优化，但程序员就能判断么？如果一个程序员能够判断这种优化是否合理的话，那么在什么情况下程序员会认为不需要这种优化呢？站在程序员的身份上，我是想不出一个不需要尾递归优化的理由的，即便可能实现出不太高效的代码，我也不会认为需要用堆栈溢出这种方式来终结一段算法是一个符合常理的做法。如果我提前有这个判断，那么就应该优化算法了。

总之我个人认为尾递归优化应该是一个默认行为。这个优化本身是比较简单的算法，同时优化之后的效果也会非常明显（执行速度与堆栈使用空间上都大有优势）。不知道我这个判断是否正确，因为这个方法是几十年前就有的，而且非常简单，但许多现在的语言就是不去实现它！这是为什么呢？——包括我最熟悉的Java语言——而kotlin语言中虽然有这个机制，但却故意设置一个关键字来提高使用的门槛，这是为什么呢？

话说回来，关于```tailrec```这个关键字在kotlin中却有一点感觉并不好的地方，就是：当一个函数并不满足尾递归优化的条件时，如果前面仍然用这个关键字来修饰，则编译器只是简单的不做优化，而不是报错。在我看来是应该报错的，因为程序员的希望是这个函数要做tail recursion，而代码的实现与程序员的要求不一致的时候，如果编译器不反馈，那么程序员可能就默认优化有效了。而如果编译器告诉程序员的话，那么程序员就有更大的机会去修改代码来满足tail recursion的要求。

# ```get/set```
第一次见到get和set关键字好像是在AS3语言中，而且我也不记得还哪个其它语言有这两个关键字。

而第一次接触get/set方法是在Java中（所谓的pojo——听说pojo概念出现之后，新的轻量级的企业级Java开发框架开始雨后春笋般的涌现，而老的（曾经无比辉煌的）J2EE逐步没落，到2018年3月，Oracle正式宣布将Java EE扫地出门）。

是否用关键字来做为get/set方法（或函数）的修饰有多大的区别呢？用关键字的好处还是有的（不过并不是非常大），可能：

1. 用关键字的话，就不用区分isSuccess和getSuccess了（虽然大部分情况下，各种框架都会认为这两个方法名是等价的）。
2. 如果有一个属性是```private boolean isSuccess;```那么要怎么命名它的get方法呢？可能也应该是```public boolean isSuccess()```——总之，如果用约定来命名的话会有各种特例。
3. 如果一开始属性被定义为public，后面再改为private之后填加get/set方法时，有关键字的是可以保持兼容性的（在AS3中get方法的调用是不用写括号的），而没有这两个关键字的就不能保持兼容了（想一下Java就知道了）。
